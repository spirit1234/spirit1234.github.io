<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ubuntu18.4安装一些软件时出现 Unable to correct problems, you have held broken packages]]></title>
    <url>%2F2019%2F03%2F12%2F%E8%A7%A3%E5%86%B3%E5%8C%85%E6%8D%9F%E5%9D%8F%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[这几天在看《揭秘家用路由器0day漏洞挖掘技术》下了ubuntu18.4，感觉Ubuntu还是不错的，发现没有Python2（mmp），安装是出现了Unable to correct problems, you have held broken packages问题（附图一张） 12345678910111213Reading package lists... DoneBuilding dependency tree Reading state information... DoneSome packages could not be installed. This may mean that you haverequested an impossible situation or if you are using the unstabledistribution that some required packages have not yet been createdor been moved out of Incoming.The following information may help to resolve the situation:The following packages have unmet dependencies: python : PreDepends: python-minimal (= 2.7.12-1~16.04) but it is not going to be installed Depends: python2.7 (&gt;= 2.7.12-1~) but it is not going to be installedE: Unable to correct problems, you have held broken packages. 查了百度许多资料都是这么说 123$ sudo apt-get upgrade$ sudo apt-get update 后来从这里他这上面说aptitude解决，尝试后发现安装这个也有相同的问题，于是又用了下面的方法，成功了。下面分享给大家： 用这条命令看你损坏的包然后卸载了123456#查看包dpkg --get-selections | grep python#卸载sudo apt-get remove libpython2.7sudo apt-get remove libpython2.7-minimalsudo apt-get remove libpython2.7-stdlib 把有关的包都卸载了，让后再1sudo apt-get insatll python 我这里的python是其中一个出现问题的，如果童鞋在安装软件是出现这个错误按这个方法处理。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[ctf交流群的加群题]]></title>
    <url>%2F2019%2F03%2F12%2Fctf%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%85%A5%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[misc题目下载Tips：https://processor.pub/2017/03/22/0CTF-2017-python%E9%80%86%E5%90%91/ 题目中有一个pyc文件先用Easy Python Decompiler将文件反编译 123456789101112131415161718192021222324252627282930313233343536# Embedded file name: test.pyimport base64part_1 = 'cmFnZVq'part_2 = '95b3Vy'part_3 = 'X2RyZWFt'part_4 = 'ISEh'def decode--- This code section failed: ---0 LOAD_GLOBAL None3 &lt;153&gt; None6 SLICE+2 None7 &lt;151&gt; None10 BINARY_ADD None11 &lt;151&gt; None14 BINARY_ADD None15 &lt;151&gt; None18 &lt;153&gt; None21 BINARY_MULTIPLY None22 BINARY_ADD None23 STORE_FAST 'secret'26 &lt;151&gt; None29 LOAD_ATTR 'b64decode'32 LOAD_FAST 'secret'35 CALL_FUNCTION_1 None38 STORE_FAST 'text'41 LOAD_FAST 'text'44 PRINT_ITEM None45 PRINT_NEWLINE_CONT None46 &lt;153&gt; None49 RETURN_VALUE None-1 RETURN_LAST NoneSyntax error at or near `&lt;151&gt;' token at offset 0 可见有两个指令是不能识别用python中的dis，和marshal 进行调试发现文件的前四位是magic number，用来识别python版本，接着的四位为时间戳123456&gt;&gt;&gt; import dis,marshal&gt;&gt;&gt; f=open("/opt/crypt.pyc")&gt;&gt;&gt; f.read(4)'\x03\xf3\r\n'&gt;&gt;&gt; f.read(4)'\xf6\xa1$[' 接下来是读取opcode，发现opcode逻辑不对，所以修改opcode来还原函数算法。123456789101112131415161718192021222324252627&gt;&gt;&gt; code = marshal.load(f)&gt;&gt;&gt; code.co_consts(-1, None, 'cmFnZVq', '95b3Vy', 'X2RyZWFt', 'ISEh', &lt;code object decode at 0x7fb03916ca30, file "test.py", line 14&gt;)&gt;&gt;&gt; dec = code.co_consts[6]&gt;&gt;&gt; dis.dis(dec.co_code) 0 &lt;151&gt; 0 3 &lt;153&gt; 1 6 SLICE+2 7 &lt;151&gt; 1 10 BINARY_ADD 11 &lt;151&gt; 2 14 BINARY_ADD 15 &lt;151&gt; 3 18 &lt;153&gt; 2 21 BINARY_MULTIPLY 22 BINARY_ADD 23 STORE_FAST 0 (0) 26 &lt;151&gt; 4 29 LOAD_ATTR 5 (5) 32 LOAD_FAST 0 (0) 35 CALL_FUNCTION 1 38 STORE_FAST 1 (1) 41 LOAD_FAST 1 (1) 44 PRINT_ITEM 45 PRINT_NEWLINE 46 &lt;153&gt; 0 49 RETURN_VALUE 然后查看有关函数的信息123456&gt;&gt;&gt; dec.co_names('part_1', 'part_2', 'part_3', 'part_4', 'base64', 'b64decode')&gt;&gt;&gt; dec.co_varnames('secret', 'text')&gt;&gt;&gt; dec.co_consts(None, -1, 2) 发现这个指令使用的传入值0，1，2，3，4。而part的几个值是在函数的外面，猜想是LOAD_GLOBAL这个指令，这个指令使用传入的值0，1，2. 调用的是varnames的值。猜想是LOAD_CONST指令，参考：https://github.com/python/cpython/blob/master/Include/opcode.hhttps://docs.python.org/2/library/dis.html#opcode-BUILD_SET读常量用的是“100”，而里面是“153”，读取全局变量是“116”使用：1234567891011121314151617181920212223&gt;&gt;&gt; dis.dis(dec.co_code.replace("\x99","\x64").replace("\x97","\x74")) 0 LOAD_GLOBAL 0 (0) 3 LOAD_CONST 1 (1) 6 SLICE+2 7 LOAD_GLOBAL 1 (1) 10 BINARY_ADD 11 LOAD_GLOBAL 2 (2) 14 BINARY_ADD 15 LOAD_GLOBAL 3 (3) 18 LOAD_CONST 2 (2) 21 BINARY_MULTIPLY 22 BINARY_ADD 23 STORE_FAST 0 (0) 26 LOAD_GLOBAL 4 (4) 29 LOAD_ATTR 5 (5) 32 LOAD_FAST 0 (0) 35 CALL_FUNCTION 1 38 STORE_FAST 1 (1) 41 LOAD_FAST 1 (1) 44 PRINT_ITEM 45 PRINT_NEWLINE 46 LOAD_CONST 0 (0) 49 RETURN_VALUE 参考：http://anhkgg.com/python-bytecode/还原程序的加密部分：1234decode() secret=part_1[:-1]+part_2+part_3+part_4 text=b64decode(secret) return test payload.py12345678910import base64part_1 = 'cmFnZVq'part_2 = '95b3Vy'part_3 = 'X2RyZWFt'part_4 = 'ISEh'secret=part_1[:-1]+part_2+part_3+part_4text=base64.b64decode(secret)print(text) 解密得到rage_your_dream!!! 其他题期待更新。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Panther ctf]]></title>
    <url>%2F2018%2F10%2F08%2FPanther%20CTF%2F</url>
    <content type="text"><![CDATA[前言第一次写writeup开始记录在我的博客这次没有做一道题就写writeup所以有些题忘了，下次比赛一定做一道写一道writeup misc你会解压吗flag99.zip1234567#!/bin/bashfor i in &#123;1..100&#125;dox=$((100-$i))unzip ./flag$x.zipdone zzzzip?flag.zip 用ziperello爆破出5位的密码然后用十六进制编辑器发现flag So many flag!lag .txt 123456789101112131415import refile=open("E:\\flag.txt",mode="r")flag=file.read()flag1=re.split(r"&#125;pctf&#123;",flag)for i in flag1: # print(i) if len(i)==20: a=re.match(r"^[a-z][A-Z][0-9].+[a-z][A-Z][a-z]$",i) print(a) print(i)# print(flag1)file.close() 出题人的心思题目是一张jpg图片用binwalk打开发现还有一张png图片然后用kali自带的分离工具将图片分开，再用十六进制改变png图片的高度，看到flag cryptojust so so!题目描述: 密文：706374667b686868685f546831735f4833785f636f64657d 答案格式: pctf{xxxxxxxxxxxxx} 12345678import reab="70,63,74,66,7b,68,68,68,68,5f,54,68,31,73,5f,48,33,78,5f,63,6f,64,65,7d"ac=re.split(",","70,63,74,66,7b,68,68,68,68,5f,54,68,31,73,5f,48,33,78,5f,63,6f,64,65,7d")print(ac)for i in ac: print(chr(eval(i))) pctf{hhhh_Th1S_H3x_code} 被加密了的flag题目描述: cpgs{Gu1f_1F_Ebg_1r} 答案格式: pctf{xxxxxxxxxxxxx} 忘记细节了，思路是26个字母表中间对折然后替换相应的字母就转换出pctf了 My math is very poor题目描述:123456789101112131415161718192021#!/usr/bin/env python# -*- coding:utf8 -*-data = 'abcdefghijklmnopqrstuvwxyz'flag = [] #[x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x]a = 9b = 13assert len(flag) == 17def encrypt(): print 'Encrypt : ', enc = '' enc_array = [] for i in range(0,len(flag)): tmp=(a*flag[i]+b)%26 enc_array.append(tmp) enc += data[tmp] print enc # yyynvjlpjccyxginp print enc_array |# [24,24,24,13,21,9,11,15,9,2,2,24,23,6,8,13,15]if __name__ == '__main__': encrypt() 答案格式: pctf{xxxxxxxxxxxxx} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 -*- coding: utf-8 -*-from string import ascii_lowercase as lowercasefrom string import ascii_uppercase as uppercasefrequencyTable = [4, 19, 14, 0, 13, 8, 17, 18, 7, 3, \ 11, 2, 20, 12, 15, 24, 22, 6, 1, 21, \ 10, 23, 9, 16, 25]# 删除预留的标点# 文本过滤def text_filter(text): text = text.lower() result = "" for i in range(len(text)): if lowercase.find(text[i]) != -1: result += text[i] return result# 加密部分def encryption(plaintext, k1, k2): plaintext = text_filter(plaintext) result = "" for i in range(len(plaintext)): index = lowercase.find(plaintext[i]) c_index = (k1 * index + k2) % 26 result += uppercase[c_index] return result# 解密部分def get_inverse(a, b): """ #求a关于模b的逆元 """ if (a == 1 and b == 0): x = 1 y = 0 return x, y else: xx, yy = get_inverse(b, a % b) x = yy y = xx - a // b * yy return x, ydef Decryption(k1, k2, ciphertext): k3 = get_inverse(k1, 26)[0] result = "" for i in range(len(ciphertext)): index = lowercase.find(ciphertext[i]) p_index = k3 * (index - k2) % 26 result += lowercase[p_index] return resultif __name__ == '__main__': ciphertext = "yyynvjlpjccyxginp" print(Decryption(9,13,ciphertext)) 仿射密码看这个博客的 其他题我也忘了。。。 reverse软件破解第一步Reverse11.exe 用ida打开就有flag了嘿嘿 come on!flag_file.pyo 这是一个Python的编译后加了防反编译模块用 easy Python Decompiler这个工具解开就可以看到源码 1234567891011121314151617181920212223# Embedded file name: /home/sliver/Documents/CTF/Python/python.pyimport base64import py_compilepy_compile.compile('/home/sliver/Documents/CTF/Python/python.py')def encode(message): s = '' for i in message: x = ord(i) x = x - 16 s += chr(x) return base64.b64encode(s)correct = 'RFhZJU8hY09AaU9DZlJaVVNk'flag = ''print 'Input flag:'flag = raw_input()if encode(flag) == correct: print 'correct,this is my flag'else: print 'wrong' 然后用 123456s="p"for i in "RFhZJU8hY09AaU9DZlJaVVNk": x=ord(i) x=x+16 s+=chr(x)print(s) 就可见flag input flagReverse3.exe用ida打开f5大法 发现DXY%O!cO@iOCfRZUSd 对flag进行处理后与这个字符串进行比较123456s="p"for i in "DXY%O!cO@iOCfRZUSd": x=ord(i) x=x+16 s+=chr(x)print(s) 可解出flag web为什么这么简单答案格式: pctf{xxxxxxxxxxxxx} 题目链接: 题目链接 [题目链接]http://47.94.4.84/web/web1abf20c91a442da48.php 用hackbar post一个比66666大的数 （最快的方法了） i’m so sadhttp://101.200.58.30/test1.php base64对字符串解码可看到代码发送get请求a[]=1$b[]=2 得到flag php is best language!http://47.94.4.84/web/web25d47c5d8a6299792.php 用hackbar postmagic_keys[]=1可得flag pctf结束]]></content>
  </entry>
</search>
